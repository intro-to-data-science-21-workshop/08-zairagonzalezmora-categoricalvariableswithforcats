---
title: "Introduction to Data Science"
subtitle: "Workshop 8. Categorical Variables with forcats"
author: "Zaira Gonzalez Mora & Luka Vasilj"
institute: "Hertie School | Berlin, Germany"
output:
  xaringan::moon_reader:
    css: [default, metropolis, metropolis-fonts] 
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: '16:9'
      hash: true
---

class: inverse, center, middle
name: categoricaldata

# Welcome to your workshop on 
<br>
# Categorical Variables with *forcats*!

<html><div style='float:left'></div><hr color='#EB811B' size=1px style="width:1000px; margin:auto;"/></html>
---


```{r setup, include=FALSE}
# figures formatting setup
options(htmltools.dir.version = FALSE)
library(knitr)
opts_chunk$set(
  prompt = T,
  fig.align="center", #fig.width=6, fig.height=4.5, 
  # out.width="748px", #out.length="520.75px",
  dpi=300, #fig.path='Figs/',
  cache=F, #echo=F, warning=F, message=F
  engine.opts = list(bash = "-l")
  )

## Next hook based on this SO answer: https://stackoverflow.com/a/39025054
knit_hooks$set(
  prompt = function(before, options, envir) {
    options(
      prompt = if (options$engine %in% c('sh','bash')) '$ ' else 'R> ',
      continue = if (options$engine %in% c('sh','bash')) '$ ' else '+ '
      )
})

library(tidyverse)
library(emojifont)
library(foreign)
library(forcats)
```
# Introduction `r emo::ji("nerd")`

Hello Tom2!

By now, we already know that **data cleaning** is important. We have realized that treating certain variables is not always so straightforward, and we worry because we know that an inadequate treatment of variables can impact our analysis. 

####  - How many times have you struggle when finding **categorical data** in your datasets? `r emo::ji("sad")`

<br>
<div align="center">
<img src="pics/dying.gif" height=200>
</div>

#### - Do not worry!

* In this workshop we will to show you how to work with **categorical data** using the **`forcats`** tool. 

* It will help you to work with **factors**. But more about about in a minute.

---
# Introduction `r emo::ji("nerd")`

### What do we need?

* To install the **`forcats`** package in R.
<br>
<div align="center">
<img src="pics/forcats2.png" height=300>
</div>

*OR*

* You can also use **`forcats`** if you have installed the tidyverse.

* Or the development version from GutHub: `devtools::install_github("tidyverse/forcats")`.

---
# What are we covering in this workshop `r emo::ji("check")`

.pull-left-wide[
<br>
<br>
1. [Categorical Data](#categoricaldata)
 
2. [Factors](#factors)
 
3. [**`forcats`**!](#forcats)
 
4. [Some useful functions from **`forcats`** + examples](#functions)
 
5. [Summary](#summary)
 ]
 
.pull-right-top[
<div align="right">
<br>
<img src="pics/rstudiologo.png" height=80>
<br>
</div>
]

---
class: inverse, center, middle
name: categoricaldata

# Categorical Data

<html><div style='float:left'></div><hr color='#EB811B' size=1px style="width:1000px; margin:auto;"/></html>

---
# Categorical Data `r emo::ji("growth")`

### What is categorical data?

* A set or collection of **categorical variables**.
<br>

### What is a categorical variable? 

* Categorical variables are those that have a fixed and known set of possible values.

* They assign each unit of observation to a particular group or nominal category.

* They represent types of data that may be divided into groups.

* Examples of categorical variables: age, group, gender, educational level, income brackets.

---

# Categorical Data `r emo::ji("growth")`

### Why can categorical variables be problematic?

* They are often stored with different values in a dataset and we need to differentiate category numbers and category labels. 

* We need consistency to work with them properly. `r emo::ji("meh")`

* Thus, we need to know their *true value* not to miss important information. 

<br>
<div align="center">
<img src="pics/strings.gif" height=200>
</div>
---
class: inverse, center, middle
name: factors

# Factors

<html><div style='float:left'></div><hr color='#EB811B' size=1px style="width:1000px; margin:auto;"/></html>

---

# Factors `r emo::ji("clockwise")`

### What are factors?

* Factors are R's data structure for categorical data. In simpler words, **R represents categorical data with factors**.

* A **factor** is an integer vector with **levels attribute** that stores a set of mappings between integers and categorical values. [**level**: all possible 'categories' of a factor'] 

* R displays not the integers from a variable, but the levels associated with them.

### Why are factors useful?

* Factors in the R language allow to treat character variables in a different way.

* Factors could be easier to work with than characters.

* Factors are helpful for reordering character vectors in non alphabetical order and to improve display.

* They allow to inspect levels in a more detailed way.

* Working with factors is a nicer alternative that working only with dummies.

---
class: inverse, center, middle
name: forcats

# Hello *forcats*!

<html><div style='float:left'></div><hr color='#EB811B' size=1px style="width:1000px; margin:auto;"/></html>

---
# Hello *forcats*! `r emo::ji("cat")`

### Nice Anagram, Hadley!
<br>
<div align="center">
<img src="pics/anagram.png" height=400>
</div>

---
# Hello *forcats*! `r emo::ji("cat")`

### Factors in the concept of tidy data

* The  **`forcats`** package provides useful tools to solve problems with factors.

* It is better to work with categorical data using tidyverse than with base R. We will see why!

<div align="center">
<img src="pics/cheatsheet.png" height=400>
</div>

---
class: inverse, center, middle
name: functions

# *forcats*: some useful functions

<html><div style='float:left'></div><hr color='#EB811B' size=1px style="width:1000px; margin:auto;"/></html>

---

# Create a new factor: factor(), as_factor

## **`factor()`**

### Description

* Base R has its own function to create factors, **`as.factor()`**, which basically encode a vector as factor. However, this function lists the levels of the factors in alphabetical order, whereas we might need different ways to ordering factors. 

* Instead, we can use the **`factor()`** function from **`forcats`**.

* **`factor()`** will create an ordered factor with assigned levels.

* You can also convert an input to a factor with **`as_factor`**.

* When x is a character, **`as_factor`** creates levels in the order in which they appear.

* When x is numeric, the ordering is based on the numeric value.

---

# Create a new factor: factor(), as_factor

We are going to use the **General Social Survey (GSS)**, a product of the National Data Program for the social Sciences from the United States. It contains data on many factors of social life. 

* You can find it here: https://gss.norc.org/get-the-data

```{r, include=FALSE}
#Load dataset
df <- read.spss("GSS2018.sav", use.value.label=TRUE, to.data.frame=TRUE) %>%
  select(INCOME, RELIG, NEWS, TVHOURS, AGE, MARITAL)

```

```{r}
#Create vector
eu_countries <- c("Poland", "Belgium", "Germany", "Malta", "Italy", "Spain", "Netherlands",
                  "Denmark", "Ireland", "Greece", "France", "Portugal", "Austria",
                  "Finland", "Cyprus", "Czechia", "Estonia", "Hungary", "Latvia",
                  "Lithuania", "Croatia", "Slovakia", "Slovenia", "Sweden", "Bulgaria",
                  "Luxembourg", "Romania")
eu_countries

```

---
# Create a new factor: factor(), as_factor

#### Using base R **`as.factor`** we would have this

```{r}
eu_countries_fct <- as.factor(eu_countries)

eu_countries_fct

```

---
# Create a new factor: factor(), as_factor

#### But what of we want to create a factor in which countries are ordered by their year of accession to the EU?

#### Let's see how it would work with **`factor()`**

```{r}
country_sample <- c(sample(eu_countries, 40, replace = T))

members <- c("Belgium", "France", "Germany", "Italy", "Luxembourg", "Netherlands",
                  "Denmark", "Ireland", "Greece", "Portugal", "Spain", "Austria",
                  "Finland", "Sweden", "Cyprus", "Czechia", "Estonia", "Hungary", "Latvia",
                  "Lithuania", "Malta", "Poland", "Slovakia", "Slovenia", "Bulgaria",
                  "Romania", "Croatia")

factor(country_sample, levels = members)
```

---

# Change levels of factors: fct_relevel


## **`fct_relevel()`**

### Description

* Factors in R come ordered and unordered. 

* Examples: small, medium, large (ordered); pen, brush, pencil (unorderded).

* If the factor is ordered, then the specific order of the levels matters (small < medium < large).

* If they're not, we need to determine the levels according our needs (maybe pencil, pen, brush?).

* **`fct_relevel()`** are useful to change the order in which the levels of a factor appear. 

* **`fct_relevel()`** reorders factor labels by hand.

* So, we could have also used **`fct_relevel()`** to do what did with **`as_factor`**.

---

#Inspect factors: fct_count()

## **`fct_count()`**

### Description

* This function is useful to count how many times each factor appears in a sample of data.

* It counts the number of values with each level.

* Addtionally, we can also check if all the levels are stored in a factor (not all factors might appear in a sample) with **`levels()`** 

* It also possible to the unique values and removing duplicates with **`fct_unique()`**

---
#Inspect factors: fct_count()

Following our example:

```{r}
#Count the times the name of a country is repeated

fct_count(country_sample, head(14))

```
---

# Inspect factors: levels()

## **`levels()`**

### Description

 * We could also check all the levels that are stored in a factor, as not all factors might appear in a sample.

* **`levels()`** returns/set the levels of a factor.

From our example:
```{r}

#Check stored levels by income

levels(df$INCOME)

```
---

# Change the order of levels: fct_reorder()

## **`fct_reorder()`**

### Description

* This function will reorder a factor based on the value of another variable, *i.e.*, it will reorder the levels by their relationship with that other variable.

* The argument to use this function is **`fct_reorder(f, x, fun)`**, where *f* is the factor, *x* is the variable according to which the reorder is happening, and *fun* is the function to determine the reordering, with the median being its default.

Going back to our example:

```{r}
#Create a plot
df %>%
  na.omit(MARITAL) %>%
  group_by(MARITAL) %>%
  summarize(age = mean(as.numeric(AGE), na.rm = T)) %>%
  ggplot(aes(age, MARITAL)) +
  geom_point()

```
```{r}
#Reorder plot!
df_marriage <- df %>%
  na.omit(MARITAL) %>%
  group_by(MARITAL) %>%
  summarize(age = mean(as.numeric(AGE), na.rm = T))
  
ggplot(df_marriage, aes(age, fct_reorder(MARITAL, age))) +
  geom_point()
```

---
# Change the value of levels: fct_collapse()

## **`fct_collapse`**

### Description

* **`forcats`** also allows to to collapse factors into other factors.

* This is particularly useful when a factor has too many levels for an easy overview, especially if the level of granularity is too high.

*  **`fct_collapse`** Collapses levels into manually defined groups.

Let's take the INCOME variable from our GSS as an example:

```{r}
df %>% ggplot(aes(x = INCOME)) +
    geom_bar()
```
---
# Change the value of levels: fct_collapse()

* It makes more sense to recategorize the data according to income classes so we use **`fct_collapse`**:

```{r}
df <- df %>%
  mutate(income_brackets = fct_collapse(INCOME, 
                                        "low" = c("LT $1000", "$1000 TO 2999", "$3000 TO 3999",
                                                  "$4000 TO 4999", "$5000 TO 5999", "$6000 TO 6999",
                                                  "$7000 TO 7999", "$8000 TO 9999", "$10000 - 14999"),
                                        "middle" = c("$15000 - 19999", "$20000 - 24999"),
                                        "high" = c("$25000 OR MORE")))

df %>% ggplot(aes(x = income_brackets)) +
    geom_bar()
```

* OR other groupings of data ranges:

```{r}
df %>% ggplot(aes(x = RELIG)) +
    geom_bar()

df %>%
  mutate(religion = fct_lump(RELIG, n = 4)) %>%
  group_by(religion) %>%
  ggplot(aes(x = religion)) +
  geom_bar()
```
---

# Change the value of levels: fct_collapse()

* Lumping levels that appear below a minimum frequency together into a single factor

```{r}
df %>% ggplot(aes(x = RELIG)) +
    geom_bar()

df %>%
  mutate(religion = fct_lump(RELIG, n = 4)) %>%
  group_by(religion) %>%
  ggplot(aes(x = religion)) +
  geom_bar()
```
---
class: inverse, center, middle
name: summary

# Summary

<html><div style='float:left'></div><hr color='#EB811B' size=1px style="width:1000px; margin:auto;"/></html>

---

# Summary

* Factors are R's data structure for categorical data.

* Categorical date is a set or collection of categorical variables.

* Categorical variables assign units of observation to a particular group or nominal category.

* Factors could be easier to work with than characters.

* The **`forcats`** package provides useful tools to solve problems with factors.

* Most useful functions from the **`forcats`** package.


